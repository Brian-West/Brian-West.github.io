---
title: 垃圾收集器和内存分配策略
---

# 垃圾收集器和内存分配策略

## 垃圾收集

垃圾收集，即GC过程，主要考虑以下三个问题：
1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？
先明确，GC主要发生在Java堆和方法区中。

### 哪些内存需要回收？如何判断对象已死？
1. 引用计数算法。
 每个已分配内存的对象都维护一个引用计数器，每次有其它地方引用自己时就把这个计数器加一，当引用失效时（可能设为null，可能发生引用行为的对象被回收），计数器减一。当GC发生时，计数器值为0的对象即“已死”，应该被回收。
 存在问题：很难解决对象之间循环引用问题。
 ```
 public class A {
	public Object instance = null;
	private byte[] size = new byte[2*1024*1024];
	public static void main() {
		A a = new A();
		A b = new A();
		a.instance = b;
		b.instance = a;

		a = null;
		b = null;

		System.gc();
	}
 }
 ```
 代码中对象a和b都被对方引用了，但是a和b这两个对象本身不可能再被访问到，因此a和b应该被回收，但是如果采用引用计数算法的话，a和b两个对象的引用计数器值都不为0那么就不会被回收。

2. 可达性分析算法。主流的商业程序语言（Java, C#, Lisp）的主流实现中采用。
 有一系列成为GC Root的对象作为起始点，建立起引用树，每一条路径都称为引用链(Reference Chain)，当一个对象到所有GC Root都没有引用链时该对象即不可达，可被回收。
 在Java中，可作为GC Root的对象有：
 - 虚拟机栈（栈帧中的局部变量表）中引用的对象；
 - 方法区中类静态属性引用的对象；
 - 方法区中常量引用的对象；
 - 本地方法栈中JNI（即一般所说的Native方法）引用的对象。

### 如何回收？垃圾收集算法。
 
