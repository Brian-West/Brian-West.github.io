---
title: 设计模式之工厂模式
---

## 最常用的工厂模式
1. 包含的组件如下：具体产品类，抽象产品父类（或接口），抽象工厂父类（或接口），具体工厂类。
2. 创建产品的职责属于工厂类，每一个具体产品都有对应的具体工厂类。
3. 客户端代码中需要用到哪个产品就创建对应的具体工厂类，可以利用读取配置文件的方式而不用在代码中明确指定哪个工厂类，这样就实现了可以在不修改任何客户端代码的基础上更换或增加所用的产品。
![图片](/images/factory3.jpg)
4. 在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。
![图片](/images/factory4.jpg)
在图中，抽象工厂类 LoggerFactory 的代码修改如下：
```
//改为抽象类
abstract class LoggerFactory {
    //在工厂类中直接调用日志记录器类的业务方法writeLog()
    public void writeLog() {
        Logger logger = this.createLogger();
        logger.writeLog();
    }

    public abstract Logger createLogger();  
}
```

## 简单的工厂模式
1. 去除工厂类的继承结构，只使用一个具体的工厂类，通过传入不同的参数指定创建不同的具体产品。
![图片](/images/factory1.jpg)
2. 可以进一步简化：将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中。
![图片](/images/factory2.jpg)

## 抽象工厂模式
1. 产品族和产品等级结构。产品族指的是类似（××键盘，××鼠标，××显示器）这样的组合，产品等级结构指的是类似（机械键盘，虚拟键盘，××键盘）这样的。
2. 可以将分别生产××键盘，××鼠标，××显示器的具体工厂合并成一个具体工厂，保证这三种产品都同时出现并且不会跟其它的产品混在一起。这些合并之后的具体工厂都继承自同一个抽象工厂。抽象产品父类（或接口）跟具体产品类都和第一种一样。
![图片](/images/factory5.jpg)
3. 添加新的产品族容易，添加新的产品结构则违背开闭原则，需要修改已有代码。添加新的产品族只需要新建具体产品类，新建具体工厂类，并且都继承各自的父类（或实现各自的接口），其它代码都不需要修改。添加新的产品结构如添加网卡的产品等级结构（有线网卡，无线网卡，××网卡），那么原有的具体工厂类需要修改，因为原本生产（××键盘，××鼠标，××显示器）的工厂现在还需要生产××网卡。抽象工厂类也需要修改。