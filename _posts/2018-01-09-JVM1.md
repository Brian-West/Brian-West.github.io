---
title: JVM的运行时数据区
---
## JVM的运行时数据区详解

Java虚拟机运行时内存区可分为两部分：
1. 线程共享的数据区。
 - 堆
 - 方法区
2. 线程隔离的数据区。
 - 程序计数器
 - 虚拟机栈
 - 本地方法栈

下面详细介绍一下各部分。
1. 程序计数器PC：同操作系统中PC相似，该区域可以看成是当前线程所执行的字节码的行号指示器，多线程的切换要求每个线程有自己的PC。但如果当前线程正在执行的是Native方法，PC的值为Undefined。此区域内存较小，没有规定任何OutOfMemoryError。

2. Java虚拟机栈：描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用到执行完成的过程就对应着一个栈帧在虚拟机栈中入栈又出栈的过程。局部变量表在编译时就可确定大小，运行时不会改变。此区域有两种异常：当线程请求的栈深度超过虚拟机所允许的最大深度（也就是本线程所执行的这些方法需要的内存过大导致虚拟机栈无法满足）时抛出大名鼎鼎的StackOverflowError异常；如果虚拟机栈可以动态扩展但是扩展时也无法申请到足够的内存则抛出OutOfMemoryError异常。

3. 本地方法栈：与虚拟机栈相似，但保存的是本地方法信息，抛出异常与虚拟机栈一致。

4. Java堆：存放对象实例，是垃圾收集器管理的主要区域。可以只要求逻辑内存空间是连续的即可，可以是可扩展的，当堆中内存不够分配给实例而且堆再也无法扩展时会抛出OutOfMemoryError异常。

5. 方法区：存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码（不懂）等数据。如何实现方法区不受虚拟机规范限制。

6. 运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用（？），程序运行时也可以将新的常量放进运行时常量池。

7. 直接内存并不是虚拟机运行时数据区的一部分，但也经常被使用。

### 普通Java对象的创建过程
 先通过类加载检查，此时对象所需内存大小即可确定，接下来在Java堆中分配内存。若堆中内存是规整的，已经分配的内存在一边，还没分配的内存在另一边，则在两个区域中间有一个指针，内存分配就是将该指针向空闲内存一边移动与对象大小相同的距离，这种方式成为指针碰撞(Bump the Pointer)。如果非规整，则需要维护一个空闲列表(Free List)，记录哪些内存块仍未被分配，将足够大的内存块分配给该对象并更新空闲列表（这部分和操作系统中磁盘和内存的管理类似，会涉及到内存块的选择策略以及所带来的问题，如碎片化）。
 并发下的问题：




